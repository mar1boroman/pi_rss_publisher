x-app: &app
  build:
    context: .
    dockerfile: Dockerfile
  image: rss_app_image:latest
  env_file:
    - .env
  depends_on:
    rss_postgres:
      condition: service_healthy

services:
  rss_postgres:
    image: postgres:16
    container_name: rss_postgres
    environment:
      POSTGRES_USER: appuser
      POSTGRES_PASSWORD: secretpass
      POSTGRES_DB: appdb
    ports:
      - "5514:5432"
    volumes:
      - rss_pgdata:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U appuser -d appdb"]
      interval: 5s
      timeout: 3s
      retries: 10
      start_period: 5s
    restart: unless-stopped

  rss_pgadmin:
    image: dpage/pgadmin4:latest
    container_name: rss_pgadmin
    environment:
      PGADMIN_DEFAULT_EMAIL: admin@example.com
      PGADMIN_DEFAULT_PASSWORD: adminpass
    ports:
      - "8686:80"
    depends_on:
      rss_postgres:
        condition: service_healthy
    volumes:
      - rss_pgadmin_data:/var/lib/pgadmin
    restart: unless-stopped

  rss_init:
    <<: *app
    command: >
      bash -lc "
        echo 'üõ†Ô∏è  Running init_db.py...';
        uv run python init_db.py &&
        echo '‚úÖ init_db complete'
      "
    restart: "no"

  rss_api:
    <<: *app
    depends_on:
      rss_postgres:
        condition: service_healthy
      rss_init:
        condition: service_completed_successfully
    command: >
      bash -lc "
        echo 'üöÄ Starting API...';
        uv run uvicorn api:app --host 0.0.0.0 --port 8000 --proxy-headers
      "
    restart: unless-stopped

  rss_worker:
    <<: *app
    depends_on:
      rss_postgres:
        condition: service_healthy
      rss_init:
        condition: service_completed_successfully
    command: >
      bash -lc '
        echo "‚è±Ô∏è scheduler every ${FETCH_INTERVAL_MINUTES:-30} minute(s)";
        while true; do
          echo "‚ñ∂Ô∏è  job start: $(date -u +%F_%T)Z";
          uv run python main.py;
          echo "‚è∏Ô∏è  sleeping ${FETCH_INTERVAL_MINUTES:-30}m";
          sleep $(( (${FETCH_INTERVAL_MINUTES:-30}) * 60 ));
        done
      '
    restart: unless-stopped

  nginx:
    image: nginx:alpine
    env_file:
      - .env
    depends_on:
      rss_api:
        condition: service_started
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx/conf.d/rss.conf.template:/etc/nginx/templates/rss.conf.template:ro
      - ./nginx/conf.d/rss.http-only.template:/etc/nginx/templates/rss.http-only.template:ro
      - ./nginx/html:/var/www/certbot
      - ./nginx/letsencrypt:/etc/letsencrypt
    command: >
      sh -c '
        apk add --no-cache gettext >/dev/null;
        CERT_PATH="/etc/letsencrypt/live/${DOMAIN_NAME}";
        if [ -f "$CERT_PATH/fullchain.pem" ] && [ -f "$CERT_PATH/privkey.pem" ]; then
          echo "üîê Certs found. Using HTTPS config.";
          envsubst "$$DOMAIN_NAME" < /etc/nginx/templates/rss.conf.template > /etc/nginx/conf.d/rss.conf;
        else
          echo "üü° No certs yet. Using HTTP-only config.";
          envsubst "$$DOMAIN_NAME" < /etc/nginx/templates/rss.http-only.template > /etc/nginx/conf.d/rss.conf;
        fi
        nginx -g "daemon off;";
      '
    restart: unless-stopped

  certbot:
    image: certbot/certbot:latest
    env_file:
      - .env
    volumes:
      - ./nginx/html:/var/www/certbot
      - ./nginx/letsencrypt:/etc/letsencrypt
    command: >
      sh -c '
        echo "üîé Checking certs for ${DOMAIN_NAME}";
        if [ ! -f "/etc/letsencrypt/live/${DOMAIN_NAME}/fullchain.pem" ]; then
          echo "‚öôÔ∏è  Issuing new certificate...";
          certbot certonly --webroot -w /var/www/certbot \
            -d "${DOMAIN_NAME}" \
            --email "${CERTBOT_EMAIL}" --agree-tos --no-eff-email;
        else
          echo "üîÅ Renewing certificate if needed...";
          certbot renew --quiet;
        fi
        echo "‚úÖ Certbot finished.";
      '
    depends_on:
      nginx:
        condition: service_started
    restart: "no"

volumes:
  rss_pgdata:
  rss_pgadmin_data: